<?php
namespace li3_pagination\extensions\helper;

use lithium\net\http\Router;
use lithium\util\Set;
use li3_pagination\extensions\data\Set as DocumentSet;

class Pagination extends \lithium\template\Helper {

	/**
	 * Default configuration. Can be changed by callig Pagination::defaults()
	 *
	 * @var array
	 */
	static $_defaults = [
		'innerWindow'   => 4,
		'outerWindow'   => 1,
		'linkSeparator' => ' ',
		'firstLabel'    => '<< First',
		'prevLabel' => '< Previous',
		'nextLabel'     => 'Next >',
		'lastLabel'     => 'Last >>',
		'activeClass'	=> 'active'
	] ;

	/**
	 * Current request.
	 *
	 * @var \lithium\action\Request
	 */
	protected $_request ;

	/**
	 * Current documents set
	 *
	 * @var \li3_pagination\extensions\data\Set
	 */
	protected $_documents ;

	/**
	 * Protected array of string templates used by this helper.
	 *
	 * Currently only one string template is being used to wrap the controls generated by the paginate() method.
	 */
	protected $_strings = [
		'wrap' => '<ul class="pagination">{:content}</ul>',
		'links-wrap' => '<li{:options}>{:content}</li>'
	];

	/**
	 * Creates a new instance of the Pagination class.
	 *
	 * Options can be configured by passing them through the $config array.
	 *
	 * @see app\extensions\helper\Pagination::_init()
	 * @param array $config An array of options that can be configured during construction.
	 *     They allow for the easy alteration of text used on prev/next links.
	 *     Valid options are:
	 *        - `'firstLabel'`: Overrides markup used for "<< First" anchor tag.
	 *        - `'prevLabel'`: Overrides markup used for "< Prev" anchor tag.
	 *        - `'nextLabel'`: Overrides markup used for "Next >" anchor tag.
	 *        - `'lastLabel'`: Overrides markup used for "Last >>" anchor tag.
	 *        - `'activeClass'`: Css class added to the active item
	 * @return object An instance of the Pagination class being constructed.
	 */
	public function __construct(array $config = []) {
		parent::__construct(Set::merge(static::$_defaults, $config));
	}

	/**
	 * Initializes the new instance of the Pagination class.
	 *
	 * Called immediately after construction, used to setup the new class with default values gathered from the current
	 * _context.
	 *
	 * @see \lithium\template\View::_renderer
	 */
	protected function _init() {
		parent::_init();
		$this->_request = $this->_context->_config['request'] ;

		// If there is only one compatible records set in the view, we catch it
		if (!empty($this->_context->_config['data'])) {
			$document = null;
			foreach($this->_context->_config['data'] as $key => $value) {
				if ($value instanceof DocumentSet) {
					// More than one : we cannot do this automatically
					if (isset($document)) {
						unset($document);
						break;
					} else {
						$document = $value;
					}
				}
			}
			$this->_documents = $document ;
		}
	}

	/**
	 * Initializes the default configuration (or return it if no $defaults array). Can be
	 * called statically from your bootstrap, for example.
	 *
	 * @param  array $defaults  (optionnal) Default configuration
	 * @return array                        Default configuration
	 */
	public static function defaults(array $defaults = null) {
		if (!isset($defaults)) {
			return static::$_defaults ;
		}

		static::$_defaults = $defaults + static::$_defaults ;
	}

	/**
	 * Updates or get the config for the current instance
	 *
	 * @param  array $config New config
	 */
	public function config(array $config = null) {
		if (!isset($config)) {
			return $this->_config ;
		}

		$this->_config = $config + $this->_config ;
	}

	/**
	 * Link to the first page.
	 *
	 * @param  array $options Options
	 * @return string         Html markup
	 */
	public function first(array $options = []) {
		list($scope, $options, $documents) = $this->_split($options);

		if ($documents->page > 1) {
			$url = $this->_url(['page' => 1]);
			$content = $this->_context->html->link($this->_config['firstLabel'], $url);
			return $this->_render(__METHOD__, 'links-wrap', compact('content', 'options'), $scope);
		}

		return '' ;
	}

	/**
	 * Link to the last page.
	 *
	 * @param  array $options Options
	 * @return string         Html markup
	 */
	public function last(array $options = []) {
		list($scope, $options, $documents) = $this->_split($options);
		$end = ceil(($documents->total / $documents->limit));

		if ($documents->page < $end) {
			$url = $this->_url(['page' => $end]);
			$content = $this->_context->html->link($this->_config['lastLabel'], $url);
			return $this->_render(__METHOD__, 'links-wrap', compact('content', 'options'), $scope);
		}

		return '' ;
	}

	/**
	 * Link to the next page.
	 *
	 * @param  array $options Options
	 * @return string         Html markup
	 */
	public function next(array $options = []) {
		list($scope, $options, $documents) = $this->_split($options);

		if ($documents->total > ($documents->limit * $documents->page)) {
			$url = $this->_url(['page' => $documents->page + 1]);
			$content = $this->_context->html->link($this->_config['nextLabel'], $url);
			return $this->_render(__METHOD__, 'links-wrap', compact('content', 'options'), $scope);
		}

		return '' ;
	}

	/**
	 * Link to the previous page.
	 *
	 * @param  array $options Options
	 * @return string         Html markup
	 */
	public function prev(array $options = []) {
		list($scope, $options, $documents) = $this->_split($options);

		if ($documents->page > 1) {
			$url = $this->_url(['page' => $documents->page - 1]);
			$content = $this->_context->html->link($this->_config['prevLabel'], $url);
			return $this->_render(__METHOD__, 'links-wrap', compact('content', 'options'), $scope);
		}

		return '' ;
	}

	/**
	 * Returns the correct documents set (local var if defined, class var otherwise)
	 *
	 * @param  \li3_pagination\extensions\data\Set $documents Documents set
	 * @return \li3_pagination\extensions\data\Set $documents Documents set
	 */
	protected function _documents(DocumentSet $documents = null) {
		if (!isset($documents)) {
			if (isset($this->_documents)) {
				return $this->_documents ;
			}
			throw new \RuntimeException('No active DocumentSet : cannot generate the pagination') ;
		}

		return $documents ;
	}

	/**
	 * Split the options and returns an array with this 3 values :
	 * - the scope options
	 * - the link options (not defined in defaults)
	 * - the documents set
	 *
	 * @param  array  $options Options
	 * @return array           Special array with always 3 values
	 */
	protected function _split(array $options) {
		$options += static::$_defaults ;

		if (isset($options['documents'])) {
			$documents = $this->_documents($options['documents']) ;
			unset($options['documents']) ;
		} else {
			$documents = $this->_documents() ;
		}

		$return = [
			array_intersect_key($options, static::$_defaults),
			array_diff_key($options, static::$_defaults),
			$documents
		] ;


		return $return ;
	}

	/**
	 * Generates the url
	 *
	 * @param  array $params Query params to force
	 * @return string        Full url
	 */
	protected function _url(array $params = []) {
		$current = !empty($this->_request->params) ? $this->_request->params : [];
		$query = !empty($this->_request->query) ? $this->_request->query : [];
		if (!empty($query['url'])) {
			unset($query['url']);
		}
		$query = $params + $query ;

		return Router::match(['?' => $query] + $current, $this->_request, ['absolute' => true]);
	}

	/**
	 * Creates the individual numeric page links, with the current link in the middle.
	 *
	 * @param array $options
	 * @return string Markup of the numeric page links.
	 */
	public function numbers(array $options = []) {
		$options += ['documents' => null] ;
		$documents = $this->_documents($options['documents']) ;
		$inner_window = (int) $this->_config['innerWindow'];
		$outer_window = (int) $this->_config['outerWindow'];
		$window_from = $documents->page - $inner_window;
		$window_to = $documents->page + $inner_window;
		$total_pages = (int) ceil($documents->total / $documents->limit);

		// adjust lower or upper limit if other is out of bounds
		if ($window_to > $total_pages) {
			$window_from -= $window_to - $total_pages;
			$window_to = $total_pages;
		}
		if ($window_from < 1) {
			$window_to += 1 - $window_from;
			$window_from = 1;
			$window_to = ($window_to > $total_pages) ? $total_pages : $window_to;
		}

		// these are always visible
		$middle = range($window_from, $window_to);

		// left window
		if ($outer_window + 3 < $middle[0]) {
			$left = range(1, $outer_window + 1);
			array_push($left, '...');
		} else {
			$left = range(1, $middle[0]);
			array_pop($left);
		}

		// right window
		if ($total_pages - $outer_window - 2 > end($middle)) {
			$right = range($total_pages - $outer_window, $total_pages);
			array_unshift($right, '...');
		} else {
			$right = end($middle) + 1 <= $total_pages ? range(end($middle) + 1, $total_pages) : [];
		}

		return array_merge_recursive($left, $middle, $right);
	}

	/**
	 * Creates a full pagination control, based on configuration options defined during construction.
	 *
	 * @param array $options
	 * @return string Markup of a full pagination control, based on config
	 *     eg: "< Prev | 1 | <strong>2</strong> | 3 | Next >".
	 */
	public function paginate(array $options = []) {
		$options += ['documents' => null] ;
		$documents = $this->_documents($options['documents']) ;
		$total_pages = ceil(($documents->total / $documents->limit));

		// early exit if there is nothing to render
		if (!($total_pages > 1)) {
			return null;
		}

		$request = $this->_request ;

		$defaults = ['escape' => true];
		list($scope, $options) = $this->_options($defaults, $options);

		$content = [] ;
		$numbers = $this->numbers(['documents' => $documents]) ;
		foreach($numbers as $page) {
			$content[] = $this->_page_number($documents, $page) ;
		}
		$content = join($this->_config['linkSeparator'], $content);

		return $this->_render(__METHOD__, 'wrap', compact('content'), $scope);
	}

	protected function _query() {
		$params = $this->_request->query;

		if (count($params) > 1) {
			unset($params['url']);
			return ['?' => $params];
		}
		return [];
	}

	protected function _page_number(DocumentSet $documents, $page) {
		$request = $this->_request ;

		$options = [];

		if ($page == $documents->page) {
			$options['class'] = 'active';
		}

		if (is_int($page)) {
			$params  = $request ? $request->params : [];
			$params += Set::merge($this->_query(), ['?' => ['page' => $page]]);

			$url = Router::match($params, $request, ['absolute' => true]);
			$content = $this->_context->html->link($page, $url);
		} else {
			$content = $this->_context->html->link($page, '#');
			$options['class'] = 'unavailable';
		}

		return $this->_render(__METHOD__, 'links-wrap', compact('content', 'options'), ['escape' => false]);
	}
}
