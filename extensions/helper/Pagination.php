<?php
namespace li3_pagination\extensions\helper;

use lithium\net\http\Router;
use lithium\util\Set;
use li3_pagination\extensions\data\PaginableSet;

/**
 * Generates pagination links for a record set.
 *
 * The easiest way to use it is to call the paginate() method, with options for displaying
 * what you want :
 * ```php
 * $this->pagination->paginate(['displayPrevNext' => false]) ; // Only pages
 * ```
 *
 * Available options :
 *   - `'linkSeparator'`: String beetween 2 links
 *   - `'firstLabel'`: Overrides markup used for "<<" anchor tag.
 *   - `'prevLabel'`: Overrides markup used for "<" anchor tag.
 *   - `'nextLabel'`: Overrides markup used for ">" anchor tag.
 *   - `'lastLabel'`: Overrides markup used for ">>" anchor tag.
 *   - `'activeClass'`: Css class added to the active item
 *   - `'pages'`: Pages you want to display
 *   - `'displayPrevNext'`: A boolean to tell the helper if you want the prev/next links calling the paginate() method
 *   - `'displayFirstLast'`: A boolean to tell the helper if you want the first/last links calling the paginate() method
 *   - `'displayPages'`: A boolean to tell the helper if you want pages numbers
 *
 * You can configure globally the helper by calling the static method defaults() from your boostrap or
 * anywhere inside your application :
 * ```php
 * Pagination::defaults(['displayFirstLast' => true]) ; // Display the first/last link by default for each paginate() call
 * ``
 */
class Pagination extends \lithium\template\Helper {

	/**
	 * Default configuration. Can be changed by callig Pagination::defaults()
	 *
	 * @var array
	 */
	static $_defaults = [
		'linkSeparator' => ' ',
		'firstLabel'    => '<<',
		'prevLabel' => '<',
		'nextLabel'     => '>',
		'lastLabel'     => '>>',
		'activeClass'	=> 'active',
		'pages' => 10,
		'displayPrevNext' => true,
		'displayFirstLast' => false,
		'displayPages' => true
	];

	/**
	 * Current request.
	 *
	 * @var \lithium\action\Request
	 */
	protected $_request;

	/**
	 * Current documents set
	 *
	 * @var \li3_pagination\extensions\data\Set
	 */
	protected $_documents;

	/**
	 * Protected array of string templates used by this helper.
	 *
	 * Currently only one string template is being used to wrap the controls generated by the paginate() method.
	 */
	protected $_strings = [
		'wrap' => '<ul class="pagination">{:content}</ul>',
		'links-wrap' => '<li{:options}>{:content}</li>'
	];

	/**
	 * Creates a new instance of the Pagination class.
	 *
	 * Options can be configured by passing them through the $config array.
	 *
	 * @see app\extensions\helper\Pagination::_init()
	 * @param array $config An array of options that can be configured during construction.
	 *     They allow for the easy alteration of text used on prev/next links.
	 *     Valid options are:
	 *
	 * @return object An instance of the Pagination class being constructed.
	 */
	public function __construct(array $config = []) {
		parent::__construct(Set::merge(static::$_defaults, $config));
	}

	/**
	 * Initializes the new instance of the Pagination class.
	 *
	 * Called immediately after construction, used to setup the new class with default values gathered from the current
	 * _context.
	 *
	 * @see \lithium\template\View::_renderer
	 */
	protected function _init() {
		parent::_init();
		$this->_request = $this->_context->_config['request'];

		// If there is only one compatible records set in the view, we catch it
		if (!empty($this->_context->_config['data'])) {
			$document = null;
			foreach($this->_context->_config['data'] as $key => $value) {
				if ($value instanceof PaginableSet) {
					// More than one : we cannot do this automatically
					if (isset($document)) {
						unset($document);
						break;
					} else {
						$document = $value;
					}
				}
			}
			$this->_documents = $document;
		}
	}

	/**
	 * Initializes the default configuration (or return it if no $defaults array). Can be
	 * called statically from your bootstrap, for example.
	 *
	 * @param  array $defaults  (optionnal) Default configuration
	 * @return array                        Default configuration
	 */
	public static function defaults(array $defaults = null) {
		if (!isset($defaults)) {
			return static::$_defaults;
		}

		static::$_defaults = $defaults + static::$_defaults;
	}

	/**
	 * Updates or get the config for the current instance
	 *
	 * @param  array $config New config
	 */
	public function config(array $config = null) {
		if (!isset($config)) {
			return $this->_config;
		}

		$this->_config = $config + $this->_config;
	}

	/**
	 * Generates the full pagination block.
	 *
	 * @param  array $options  Options
	 * @return string          Html markup
	 */
	public function paginate(array $options = []) {
		list($scope, $unused, $documents) = $this->_split($options);

		$start = [];
		$end = [];

		if ($scope['displayFirstLast']) {
			$start[] = $this->first($options);
			$end[] = $this->last($options);
		}
		if ($scope['displayPrevNext']) {
			$start[] = $this->prev($options);
			array_unshift($end, $this->next($options));
		}
		if ($scope['displayPages']) {
			$start[] = $this->pages($options) ;
		}

		$content = implode($scope['linkSeparator'], array_merge($start, $end));

		return $this->_render(__METHOD__, 'wrap', compact('content'), $scope);
	}

	/**
	 * Link to the first page.
	 *
	 * @param  array $options Options
	 * @return string         Html markup
	 */
	public function first(array $options = []) {
		list($scope, $options, $documents) = $this->_split($options);

		if ($documents->page > 1) {
			$url = $this->_url(['page' => 1]);
			$content = $this->_context->html->link($this->_config['firstLabel'], $url);
			return $this->_render(__METHOD__, 'links-wrap', compact('content', 'options'), $scope);
		}

		return '' ;
	}

	/**
	 * Link to the last page.
	 *
	 * @param  array $options Options
	 * @return string         Html markup
	 */
	public function last(array $options = []) {
		list($scope, $options, $documents) = $this->_split($options);
		$end = ceil(($documents->total / $documents->limit));

		if ($documents->page < $end) {
			$url = $this->_url(['page' => $end]);
			$content = $this->_context->html->link($this->_config['lastLabel'], $url);
			return $this->_render(__METHOD__, 'links-wrap', compact('content', 'options'), $scope);
		}

		return '' ;
	}

	/**
	 * Link to the next page.
	 *
	 * @param  array $options Options
	 * @return string         Html markup
	 */
	public function next(array $options = []) {
		list($scope, $options, $documents) = $this->_split($options);

		if ($documents->total > ($documents->limit * $documents->page)) {
			$url = $this->_url(['page' => $documents->page + 1]);
			$content = $this->_context->html->link($this->_config['nextLabel'], $url);
			return $this->_render(__METHOD__, 'links-wrap', compact('content', 'options'), $scope);
		}

		return '' ;
	}

	/**
	 * Link to the previous page.
	 *
	 * @param  array $options Options
	 * @return string         Html markup
	 */
	public function prev(array $options = []) {
		list($scope, $options, $documents) = $this->_split($options);

		if ($documents->page > 1) {
			$url = $this->_url(['page' => $documents->page - 1]);
			$content = $this->_context->html->link($this->_config['prevLabel'], $url);
			return $this->_render(__METHOD__, 'links-wrap', compact('content', 'options'), $scope);
		}

		return '' ;
	}

	/**
	 * Pages links.
	 *
	 * @param  array $options Options
	 * @return string         Html markup
	 */
	public function pages(array $options = []) {
		list($scope, $options, $documents) = $this->_split($options);

		$numbers = $this->_numbers($documents, $scope);
		if ($numbers) {
			$content = [];
			foreach($numbers as $page) {
				$content[] = $this->_pageNumber($documents, $page, $scope, $options);
			}
			return join($this->_config['linkSeparator'], $content);
		}

		return '';
	}

	/**
	 * Calculates an array with all the pages numbers for the current documents set.
	 *
	 * @param  PaginableSet $documents The documents
	 * @param  array       $options   Options
	 * @return array                  Range of pages to display
	 */
	protected function _numbers(PaginableSet $documents, array $options) {
		$pages = ceil($documents->total / $documents->limit);

		if ($pages > 1) {
			$page = $documents->page;
			$numbers = $options['pages'];

			if ($page + $numbers < $pages) {
				$first = max(1, floor($page - ($numbers / 2)));
				$last = min($first + $numbers - 1 , $pages);
			} else {
				$last = $pages;
				$first = max(1, $last - $numbers + 1);
			}

			return range($first, $last);
		}
		return null ;
	}

	/**
	 * Display a page number.
	 *
	 * @param  PaginableSet $documents Doccuments set
	 * @param  int         $page      Current page
	 * @param  array       $scope     Scope options
	 * @param  array       $options   Link options
	 * @return string                 Html markup
	 */
	protected function _pageNumber(PaginableSet $documents, $page, array $scope, array $options) {
		if ($page == $documents->page) {
			$options['class'] = !empty($options['class']) ? $options['class'] . ' ' . $scope['activeClass'] : $scope['activeClass'];
		}

		$url = $this->_url(['page' => $page]);
		$content = $this->_context->html->link($page, $url);

		return $this->_render(__METHOD__, 'links-wrap', compact('content', 'options'), ['escape' => false]);
	}

	/**
	 * Returns the correct documents set (local var if defined, class var otherwise)
	 *
	 * @param  \li3_pagination\extensions\data\Set $documents Documents set
	 * @return \li3_pagination\extensions\data\Set $documents Documents set
	 */
	protected function _documents(PaginableSet $documents = null) {
		if (!isset($documents)) {
			if (isset($this->_documents)) {
				return $this->_documents;
			}
			throw new \RuntimeException('No active PaginableSet : cannot generate the pagination');
		}

		return $documents;
	}

	/**
	 * Split the options and returns an array with this 3 values :
	 * - the scope options
	 * - the link options (not defined in defaults)
	 * - the documents set
	 *
	 * @param  array  $options Options
	 * @return array           Special array with always 3 values
	 */
	protected function _split(array $options) {
		$options += static::$_defaults;

		if (isset($options['documents'])) {
			$documents = $this->_documents($options['documents']);
			unset($options['documents']);
		} else {
			$documents = $this->_documents();
		}

		$return = [
			array_intersect_key($options, static::$_defaults),
			array_diff_key($options, static::$_defaults),
			$documents
		] ;

		return $return;
	}

	/**
	 * Generates the url
	 *
	 * @param  array $params Query params to force
	 * @return string        Full url
	 */
	protected function _url(array $params = []) {
		$current = !empty($this->_request->params) ? $this->_request->params : [];
		$query = !empty($this->_request->query) ? $this->_request->query : [];
		if (!empty($query['url'])) {
			unset($query['url']);
		}
		$query = $params + $query ;

		return Router::match(
			!empty($query) ? ['?' => $query] + $current : $current,
			$this->_request,
			['absolute' => true]);
	}
}
